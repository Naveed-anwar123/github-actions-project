name: node app workflow
on:
  workflow_dispatch:
  push:
    branches:
      - main
      - feature/*
env: # these are setup at the environment in the runner
  MONGO_URI: mongodb+srv://supercluster.d83jj.mongodb.net/superData # let say this is prod database
  MONGO_USERNAME: ${{ vars.MONGO_USERNAME }} # access repository level variables
  MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }} # access repository level secrets
  REPO: naveed-anwar123

jobs:
  # unit-testing:
  #   strategy:
  #     matrix:
  #       nodejs_version: [18]
  #       operating_system: [ubuntu-latest, macos-latest]
  #       exclude:
  #         - nodejs_version: 18
  #           operating_system: macos-latest
  #   runs-on: ${{ matrix.operating_system }}
  #   services:
  #     mongo-db:
  #       image: siddharth67/mongo-db:non-prod
  #       ports: 
  #         - 27017:27017
  #   env: # these are setup at the environment in the runner
  #     MONGO_URI: mongodb://localhost:27017/superData # let say this is prod database
  #     MONGO_USERNAME: non-prod-user
  #     MONGO_PASSWORD: non-prod-password
  #   name: unit-testing
  #   steps:
  #     - name: Repository Checkout # download repo
  #       uses: actions/checkout@v4 

  #     - name: Setup Node
  #       uses: actions/setup-node@v4 # install node
  #       with:
  #         node-version: ${{ matrix.nodejs_version }}
      
  #     - name: Cache Node Dependencies
  #       uses: actions/cache@v3
  #       with:
  #         path: node_modules # where the dependencies are installed
  #         key: ${{runner.os}}-node-modules-${{hashFiles('package-lock.json')}} # unique key to create and load cache
          
  #     - name: Install dependencies # install dependecies
  #       run: npm install

  #     - name: Run Tests # run the unit tests
  #       id: nodejs_unit_test_id # give a unique id id
  #       run: |
  #         npm test
  #         ls -ltrh

  #     - name: Archive test result for ${{ matrix.operating_system }}-${{ strategy.job-index }}
  #       #if: failure() && (steps.nodejs_unit_test_id.outcome == 'failure' || steps.nodejs_unit_test_id.outcome == 'success')
  #       if: always()
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: Result-${{ matrix.operating_system }}-${{ strategy.job-index }} # to generate random names
  #         path: test-results.xml # where the file is present on the runner vm

  # code-coverage: 
  #   strategy:
  #     matrix:
  #       nodejs_version: [18]
  #       operating_system: [ubuntu-latest]
  #   runs-on: ${{ matrix.operating_system }}

  #   container: # RUNS the job inside a container on the runner virtual machine
  #     image: node:18
    
  #   services:
  #     mongo-db:
  #       image: siddharth67/mongo-db:non-prod
  #       options:
  #         --name mongo
  #   env: # these are setup at the environment in the runner
  #     MONGO_URI: mongodb://mongo:27017/superData # let say this is prod database
  #     MONGO_USERNAME: non-prod-user
  #     MONGO_PASSWORD: non-prod-password

  #   name: code coverage 
  #   steps:
  #     - name: Repository Checkout # download repo
  #       uses: actions/checkout@v4 

  #     # - name: Setup Node 18
  #     #   uses: actions/setup-node@v4 # install node
  #     #   with:
  #     #     node-version: 18
      
  #     - name: Cache Node Dependencies
  #       uses: actions/cache@v3
  #       with:
  #         path: node_modules # where the dependencies are installed
  #         key: ${{runner.os}}-node-modules-${{hashFiles('package-lock.json')}} # unique key to create and load cache
          
  #     - name: Install dependencies # install dependecies
  #       run: npm install

  #     - name: Run Coverage # run the unit tests
  #       run: npm run coverage
  #       continue-on-error: true

  #     - name: Code Coverage Results
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: Code-Coverage-${{ matrix.operating_system }}-${{ strategy.job-index }} # to generate random names
  #         path: coverage # where the file is present on the runner vm
  #         retention-days: 5
  
  # docker:
  #   name: Containerization job
  #   runs-on: ubuntu-latest
  #   needs: [code-coverage, unit-testing]
  #   permissions: # add permissions for the GITHUB_TOKENs
  #     packages: write
  #     contents: read
  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v4
      
  #     - name: Login to Docker Hub
  #       uses: docker/login-action@v3
  #       with:
  #         username: ${{ vars.DOCKERHUB_USERNAME }}
  #         password: ${{ secrets.DOCKERHUB_PASSWORD }}
      
  #     - name: Login to GITHUB Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.repository_owner }}
  #         password: ${{ secrets.GITHUB_TOKEN }} # at the start of each job, github generates this token, as soon as job finishes, this token expires, we need to define permissions at the job level

  #     - name: Build and push
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: . # Path where we have the docker file is
  #         push: false
  #         tags: ${{ vars.DOCKERHUB_USERNAME}}/solar-system:${{github.sha}}

  #     - name: Docker Image Testing
  #       run: |
  #         docker images
  #         docker run --name solar-system-app -d \
  #           -p 3000:3000 \
  #           -e MONGO_URI=$MONGO_URI \
  #           -e MONGO_USERNAME=$MONGO_USERNAME \
  #           -e MONGO_PASSWORD=$MONGO_PASSWORD \
  #           ${{ vars.DOCKERHUB_USERNAME}}/solar-system:${{github.sha}}
          
  #         docker container ls
  #         wget -q -O - localhost:3000/live | grep live
      
  #     - name: Container Registry Push
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: .
  #         push: true # push image to docker hub
  #         tags: | 
  #           ${{ vars.DOCKERHUB_USERNAME}}/solar-system:${{github.sha}}
  #           ghcr.io/${{env.REPO}}/solar-system:${{github.sha}}
  
  dev-deploy:
    #needs: docker
    runs-on: ubuntu-latest
    steps:
      - name: Repository Checkout # download repo
        uses: actions/checkout@v4 
    
      - name: Install kubectl cli
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.26.0'
        id: install
      - name: Set kubeconfig
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBECONFIG }}

      - name: Fetch kubectl cluster information
        run: | 
          kubectl version -o yaml
          echo -------------------------------
          kubectl get nodes
          echo -------------------------------  
      
      - name: Get Ingress External IP and save into GITHUB environment variable
        run: | # how to save any variable in github environment
            echo "INGRESS_IP=$(kubectl get svc ingress-nginx-controller --namespace=ingress-nginx -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')" >> "$GITHUB_ENV"

      - name: Replace Tokens in manifest files
        uses: cschleiden/replace-tokens@v1
        with:
          tokenPrefix: '${' # ${NAMESPACE} will be replaced with development
          tokenSuffix: '}'
          files: '["kubernetes/development/*.yaml"]'
        env:
          NAMESPACE: ${{vars.NAMESPACE}}
          REPLICAS: ${{vars.REPLICAS}}
          IMAGE:  ${{ vars.DOCKERHUB_USERNAME}}/solar-system:${{github.sha}}
          INGRESS_IP: ${{env.INGRESS_IP}}
      
      - name: Check files
        run: | 
          cat kubernetes/development/*.yaml

      - name: Create MongoDB Secret
        run: |
          kubectl -n ${{vars.NAMESPACE}} create secret generic mongo-db-creds \
          --from-literal=MONGO_URI=${{ env.MONGO_URI }} \
          --from-literal=MONGO_PASSWORD=${{ env.MONGO_PASSWORD }} \
          --from-literal=MONGO_USERNAME=${{ env.MONGO_USERNAME }} \
          --save-config \
          --dry-run=client \
          -o yaml | kubectl apply -f -

      - name: Deploy to Dev ENV
        run: | 
          kubectl apply -f kubernetes/development
      
      